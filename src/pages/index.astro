---
import Layout from "../layouts/Layout.astro";
---

<!-- A Taiko no Tastujin clone -->
<Layout title="Taiko no Shoshinsha">
    <script>
        import p5 from "p5";
        import {v4 as uuidv4} from 'uuid';

        let enteredMainDrawLoop = false;

        const barY = 350;
        const barHeight = 210;

        const bottomBarHeight = 50;

        const visualisationAreaWidth = 525;

        const padWidthRatio = 0.33;
        const padX = window.innerWidth * padWidthRatio
        const padY = barY + barHeight / 2;
        const padRadius = 175;

        const noteRadius = 125;
        const noteBigRadius = 200;

        const splashRadius = 300

        const drumWidth = 168 * (barHeight + bottomBarHeight) / 192;
        const drumHeight = 192 * (barHeight + bottomBarHeight) / 192;
        const drumRightPadding = 15;
        const drumTopPadding = 5;

        const goodTextWidth = 112 * (10/7);
        const okTextWidth = 72 * (10/7);
        const badTextWidth = 88 * (10/7);
        const textHeight = 64 * (10/7);
        const textBottomPadding = 80;

        // speed is a multiplier, where x means the notes move 1 pixel per frame
        const speed = (7) * 10;

        let bpm: number;
        // In seconds
        let barDuration: number;
        // In seconds
        let offset: number;

        let frame = 0;
        const frameRate = 60;

        // sprites
        let don_1: p5.Image;
        let ka_1: p5.Image;

        let b_don_4: p5.Image;
        let b_ka_4: p5.Image;

        let pad: p5.Image;

        let good: p5.Image;
        let ok: p5.Image;

        let b_good: p5.Image;
        let b_ok: p5.Image;

        let pad_good: p5.Image;
        let pad_ok: p5.Image;

        let b_pad_good: p5.Image;
        let b_pad_ok: p5.Image;

        let drum: p5.Image;

        let drum_don_right: p5.Image;
        let drum_don_left: p5.Image;

        let drum_ka_right: p5.Image;
        let drum_ka_left: p5.Image;

        let good_text: p5.Image;
        let ok_text: p5.Image;
        let bad_text: p5.Image;

        let song;
        let don_sound;
        let ka_sound;

        let notesToDestroy: (string | number)[][] = [];

        let destroyedNoteBig: Boolean;
        let destroyedNoteType: NoteType;
        let destroyedNoteAccuracy: number;
        let maintainedFrames: number;

        let tappedDrumType: NoteType;
        let tappedDrumSide: number;
        let tappedDrumMaintainedFrames: number;

        let textMaintainedFrames: number;

        let combo = 0;

        let frameError = 0;

        enum NoteType {
            DON,
            KA
        }

        const line = (x1: number, y1: number, x2: number, y2: number) => {
            const m = (y2 - y1) / (x2 - x1);
            const c = y1 - m * x1;
            return (x: number) => m * x + c;
        };

        const generateBezier = (start: number[], control1: number[], control2: number[], end: number[]) => {
            return function(t) {
                let x = Math.pow(1 - t, 3) * start[0] + 3 * Math.pow(1 - t, 2) * t * control1[0] + 3 * (1 - t) * Math.pow(t, 2) * control2[0] + Math.pow(t, 3) * end[0];
                let y = Math.pow(1 - t, 3) * start[1] + 3 * Math.pow(1 - t, 2) * t * control1[1] + 3 * (1 - t) * Math.pow(t, 2) * control2[1] + Math.pow(t, 3) * end[1];
                return [x, y];
            };
        }

        const easeOutCurve = generateBezier([0, 0], [0.5, 0], [0, 0.4], [1, 0.8]);

        class Note {
            id: string = uuidv4();
            x: number;
            xEnd: number;
            xStart: number;
            yEnd: number;
            type: NoteType;
            big: boolean;

            f: (x: number) => number;

            constructor(x: number, type: NoteType = NoteType.DON, big: boolean = false) {
                this.x = x;
                // xEnd represents frame, and yEnd represents the x position of the note.
                // When the Note reaches the pad, its x position will be yEnd, on frame xEnd.
                this.xEnd = x * frameRate;
                this.xStart = this.xEnd - speed;
                this.yEnd = padX;
                this.type = type;
                this.big = big;

                this.f = line(this.xStart, window.innerWidth, this.xEnd, this.yEnd);
            }

            getRealX = (frame: number, deltaTime: number) => {
                // This is the x coordinate of the note.
                // Using deltaTime, we can calculate the x position of the note at any given frame.
                return this.f(frame);
            };

            size = () => {
                return this.big ? noteBigRadius : noteRadius;
            }
        }

        let notes: Note[] = [];

        const findClosestIndex = (arr, target) => {
            let left = 0;
            let right = arr.length - 1;

            while (left <= right) {
                let mid = Math.floor((left + right) / 2);

                if (arr[mid] === target) {
                    return mid;
                } else if (arr[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            // At this point, left is the index where the target should be inserted
            // to maintain sorted order. So, we check which is closer, left or right.
            if (left >= arr.length) {
                return right; // edge case if target is larger than any element in arr
            } else if (right < 0) {
                return left; // edge case if target is smaller than any element in arr
            } else {
                return (Math.abs(arr[left] - target) < Math.abs(arr[right] - target)) ? left : right;
            }
        }

        interface Metadata {
            [key: string]: string;
        }

        const parseMetadata = (contents: string): Metadata => {
            const metadata: Metadata = {};
            const lines = contents.split('\n');

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#')) {
                    break; // Stop parsing once we encounter a line starting with '#'
                }
                if (trimmedLine) {
                    const [key, value] = trimmedLine.split(':');
                    metadata[key.trim()] = value.trim();
                }
            }

            return metadata;
        }

        const parseNotes = (contents: string): Note[] => {
            let parsedNotes: Note[] = [];

            // Go to #Start
            let lines = contents.split('\n');
            let start = 0;
            for (let i = 0; i < lines.length; ++i) {
                if (lines[i].trim() === '#START') {
                    start = i;
                    break;
                }
            }

            // Discard all lines before and including #Start
            lines = lines.slice(start + 1);

            // Discard all lines that start with #
            lines = lines.filter((line) => !line.trim().startsWith('#'));

            // Discard all blank lines
            lines = lines.filter((line) => line.trim() !== '');

            // Parse the notes
            for (let i = 0; i < lines.length; ++i) {
                lines[i] = lines[i].trim().slice(0, -1);
                const duration = barDuration / lines[i].length;

                for (let j = 0; j < lines[i].length; ++j) {
                    if (lines[i][j] === '1') {
                        parsedNotes.push(new Note(j * duration + (i * barDuration) - offset, NoteType.DON));
                    } else if (lines[i][j] === '2') {
                        parsedNotes.push(new Note(j * duration + (i * barDuration) - offset, NoteType.KA));
                    } else if (lines[i][j] === '3') {
                        parsedNotes.push(new Note(j * duration + (i * barDuration) - offset, NoteType.DON, true));
                    } else if (lines[i][j] === '4') {
                        parsedNotes.push(new Note(j * duration + (i * barDuration) - offset, NoteType.KA, true));
                    }
                }
            }

            return parsedNotes;
        }

        const preload = (p: p5) => {
            don_1 = p.loadImage("/sprites/don_1.png");
            ka_1 = p.loadImage("/sprites/ka_1.png");

            b_don_4 = p.loadImage("/sprites/b_don_4.png");
            b_ka_4 = p.loadImage("/sprites/b_ka_4.png");

            pad = p.loadImage("/sprites/pad.png");

            good = p.loadImage("/sprites/good.png");
            ok = p.loadImage("/sprites/ok.png");

            b_good = p.loadImage("/sprites/b_good.png");
            b_ok = p.loadImage("/sprites/b_ok.png");

            pad_good = p.loadImage("/sprites/pad_good.png");
            pad_ok = p.loadImage("/sprites/pad_ok.png");

            b_pad_good = p.loadImage("/sprites/b_pad_good.png");
            b_pad_ok = p.loadImage("/sprites/b_pad_ok.png");

            drum = p.loadImage("/sprites/drum.png");

            drum_don_right = p.loadImage("/sprites/drum_don_right.png");
            drum_don_left = p.loadImage("/sprites/drum_don_left.png");

            drum_ka_right = p.loadImage("/sprites/drum_ka_right.png");
            drum_ka_left = p.loadImage("/sprites/drum_ka_left.png");

            good_text = p.loadImage("/sprites/good_text.png");
            ok_text = p.loadImage("/sprites/ok_text.png");
            bad_text = p.loadImage("/sprites/bad_text.png");

            song = new Audio("/songs/Idol.ogg");
            don_sound = new Audio("/sounds/Don.wav");
            ka_sound = new Audio("/sounds/Katsu.wav");

            // Load the TJA file
            fetch("/tjas/Idol.tja")
                .then((response) => response.text())
                .then((contents) => {
                    const metadata = parseMetadata(contents);
                    bpm = parseFloat(metadata["BPM"]);
                    barDuration = 4 * 60 / bpm;
                    offset = parseFloat(metadata["OFFSET"]);
                    notes = parseNotes(contents);
                    console.log(bpm, barDuration, offset);
                });
        };

        const setup = (p: p5) => {
            p.createCanvas(window.innerWidth, window.innerHeight);
            p.background(255);
            p.strokeWeight(6);
            p.frameRate(frameRate);
        };

        const draw = (p: p5) => {
            p.clear();
            // Scrolling Bar
            p.fill("#2C2A2C");
            p.rect(0, barY, window.innerWidth, barHeight);

            p.fill("#847F84");
            p.rect(0, barY + barHeight, window.innerWidth, bottomBarHeight);

            p.image(
                pad,
                padX - padRadius / 2,
                padY - padRadius / 2,
                padRadius,
                padRadius
            )

            let noteIDsToDestroy = notesToDestroy.map((n) => n[0]);
            notes = notes.filter((n) => {
                if (noteIDsToDestroy.includes(n.id) && n.xEnd <= frame) {
                    noteIDsToDestroy = noteIDsToDestroy.filter((id) => id !== n.id);
                    destroyedNoteBig = n.big;
                    destroyedNoteType = n.type;
                    destroyedNoteAccuracy = <number>notesToDestroy.find((x) => x[0] === n.id)[1];
                    maintainedFrames = 3;
                    textMaintainedFrames = 10;
                    return false;
                }
                return true;
            });

            for (let i = 0; i < notes.length; ++i) {
                const x = notes[i].getRealX(frame, p.deltaTime);

                p.image(
                    notes[i].type === NoteType.DON ? (notes[i].big ? b_don_4 : don_1) : (notes[i].big ? b_ka_4 : ka_1),
                    x - notes[i].size() / 2,
                    barY + barHeight / 2 - notes[i].size() / 2,
                    notes[i].size(),
                    notes[i].size()
                )
            }

            p.fill("#FA4529");
            p.rect(0, barY, visualisationAreaWidth, barHeight + bottomBarHeight);

            p.image(
                drum,
                visualisationAreaWidth - drumWidth - drumRightPadding,
                barY + drumTopPadding,
                drumWidth,
                drumHeight
            )

            p.strokeWeight(10);
            p.line(0, barY, window.innerWidth, barY);
            p.line(0, barY + barHeight + bottomBarHeight, window.innerWidth, barY + barHeight + bottomBarHeight);
            p.strokeWeight(6);

            if (maintainedFrames) {
                if (destroyedNoteAccuracy !== 2) {
                    let imageToUse;
                    if (destroyedNoteBig) {
                        imageToUse = destroyedNoteAccuracy === 0 ? b_good : b_ok;
                    } else {
                        imageToUse = destroyedNoteAccuracy === 0 ? good : ok;
                    }
                    p.image(
                        imageToUse,
                        padX - splashRadius / 2,
                        padY - splashRadius / 2,
                        splashRadius,
                        splashRadius
                    )
                }

                --maintainedFrames;
            }

            if (textMaintainedFrames) {
                const textImages = [good_text, ok_text, bad_text];
                const textWidths = [goodTextWidth, okTextWidth, badTextWidth];

                p.image(
                    textImages[destroyedNoteAccuracy],
                    padX - textWidths[destroyedNoteAccuracy] / 2,
                    padY - textHeight - textBottomPadding,
                    textWidths[destroyedNoteAccuracy],
                    textHeight
                );

                --textMaintainedFrames;
            }

            if (tappedDrumMaintainedFrames) {
                // Use easeOutCurve for transparency
                p.tint(255, 255 * easeOutCurve(tappedDrumMaintainedFrames / 7)[1]);

                let imageToUse;
                if (tappedDrumType === NoteType.DON) {
                    imageToUse = tappedDrumSide === 0 ? drum_don_left : drum_don_right;
                } else {
                    imageToUse = tappedDrumSide === 0 ? drum_ka_left : drum_ka_right;
                }
                p.image(
                    imageToUse,
                    visualisationAreaWidth - drumWidth - drumRightPadding,
                    barY + drumTopPadding,
                    drumWidth,
                    drumHeight
                )
                p.noTint();

                --tappedDrumMaintainedFrames;
            }

            p.fill("#FA4529");
            p.text("fps: " + p.frameRate().toFixed(2), 10, 10);

            frame += 1;
        };

        const keyPressed = (p: p5) => {
            const noteIDsToDestroy = notesToDestroy.map((n) => n[0]);
            const withoutToDestroy = notes.filter((n) => !noteIDsToDestroy.includes(n.id));
            let closest = findClosestIndex(withoutToDestroy.map((n) => n.xEnd), frame);

            const keyToNoteType = {
                "d": NoteType.KA,
                "f": NoteType.DON,
                "j": NoteType.DON,
                "k": NoteType.KA
            };

            const triggeredNoteType = keyToNoteType[p.key];

            const noteTypeToSound = {
                [NoteType.DON]: don_sound,
                [NoteType.KA]: ka_sound
            };

            tappedDrumMaintainedFrames = 7;
            tappedDrumType = triggeredNoteType;
            tappedDrumSide = p.key === 'd' || p.key === 'f' ? 0 : 1;

            noteTypeToSound[triggeredNoteType]?.cloneNode(true).play();

            if (withoutToDestroy[closest].type === triggeredNoteType) {
                const accuracy = Math.abs(withoutToDestroy[closest].xEnd - frame);
                if (accuracy < 2) {
                    notesToDestroy.push([withoutToDestroy[closest].id, 0]);
                } else if (accuracy < 4) {
                    notesToDestroy.push([withoutToDestroy[closest].id, 1]);
                } else if (accuracy < 6) {
                    notesToDestroy.push([withoutToDestroy[closest].id, 2]);
                }
            }
        }

        let sketch = (p: p5) => {
            p.preload = () => {
                preload(p);
            };
            p.setup = () => {
                setup(p);
            };

            p.draw = () => {
                if (!enteredMainDrawLoop) {
                    p.textSize(32);
                    p.textAlign(p.CENTER, p.CENTER);

                    p.text("Press F or J for Red Notes, and D or K for Blue Notes. Click to start.", window.innerWidth / 2, window.innerHeight / 2);
                }

                if (p.mouseIsPressed && !enteredMainDrawLoop) {
                    song.play();
                    enteredMainDrawLoop = true;
                }

                if (enteredMainDrawLoop) {
                    draw(p);
                }
            };

            p.keyPressed = () => {
                keyPressed(p);
            }
        };

        new p5(sketch, document.getElementById("sketch"));
    </script>

    <div id="sketch"></div>
</Layout>
